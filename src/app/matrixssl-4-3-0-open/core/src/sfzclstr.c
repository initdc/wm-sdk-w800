/* sfzclstr.c

   Implementation of simple character set and string handling routines. These
   are needed in the X.509 PKIX compatible library.

   We take the following approach with the character sets:

    1. We work based on the 16-bit BMP set which is a subset of
       UCS-4 (it is called also UCS-2).

    2. All 8-bit sets are defined by referring to BMP (UCS-2).

    3. Only 8-bit (or 7-bit) tables are defined for handling of
       special charsets. These point to the 16-bit set.

    4. Mappings between 8-bit sets are done by construction suitable
       16-bit tables on the fly and doing the transformation there.
       If possible, that is.

    5. Canonical transformation is as follows:

       a) Remove all whitespace that doesn't separate characters.
       b) Make all letters lowercase (if possible, this is defined to
          work only for ISO 646 or related).
 */

/*****************************************************************************
* Copyright (c) 2006-2016 INSIDE Secure Oy. All Rights Reserved.
*
* The latest version of this code is available at http://www.matrixssl.org
*
* This software is open source; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This General Public License does NOT permit incorporating this software
* into proprietary programs.  If you are unable to comply with the GPL, a
* commercial license for this software may be purchased from INSIDE at
* http://www.insidesecure.com/
*
* This program is distributed in WITHOUT ANY WARRANTY; without even the
* implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
* http://www.gnu.org/copyleft/gpl.html
*****************************************************************************/

#include "sfzclincludes.h"
#include "sfzclstr.h"
#include "implementation_defs.h"

#define SFZCL_DEBUG_MODULE "SfzclStr"

/* The string data structure. */
struct SfzclStrRec
{
    SfzclCharset charset;       /* character set in use. */
    unsigned int bits;          /* string bits. */
    size_t str_length;
    union
    {
        unsigned char *str_8bit;
        uint16_t *str_16bit;
        uint32_t *str_32bit;
    } ob;
    size_t mem_length;          /* total number of bytes allocated. */
};

/* Basic string interface. */

/* Note: It would be possible to write the UTF-8 encoding and decoding
   with using string routine append capability rather than having
   adhoc buffer routines as above I do. */

static bool
sfzcl_str_realloc(SfzclStr str, size_t new_length)
{
    uint32_t *newp = NULL;

#define STR_REALLOC 256

    if (str->mem_length < new_length)
    {
        if ((newp =
                 SPAL_Memory_Alloc((new_length + STR_REALLOC) * (str->bits / 8))) !=
            NULL)
        {
            str->mem_length = new_length + STR_REALLOC;
            switch (str->bits)
            {
            case 8:
                c_memcpy(newp,
                    str->ob.str_8bit,
                    str->str_length * sizeof(unsigned char));
                SPAL_Memory_Free(str->ob.str_8bit);
                str->ob.str_8bit = (unsigned char *) newp;
                break;

            case 16:
                c_memcpy(newp,
                    str->ob.str_16bit, str->str_length * sizeof(uint16_t));
                SPAL_Memory_Free(str->ob.str_16bit);
                str->ob.str_16bit = (uint16_t *) newp;
                break;

            case 32:
                c_memcpy(newp,
                    str->ob.str_32bit, str->str_length * sizeof(uint32_t));
                SPAL_Memory_Free(str->ob.str_32bit);
                str->ob.str_32bit = (uint32_t *) newp;
                break;

            default:
                L_DEBUG(LF_TOTAL_PROGRESS,
                    "Failed to convert charset %u (%u bit chars).",
                    str->charset, str->bits);
                SPAL_Memory_Free(newp);
                newp = NULL;
                break;
            }
        }
        if (newp == NULL)
        {
            return FALSE;
        }
    }
    return TRUE;
}

bool
sfzcl_str_get_letter(SfzclStr str, size_t pos, uint32_t *letter)
{
    if (str == NULL || pos >= str->str_length)
    {
        return FALSE;
    }

    switch (str->bits)
    {
    case 8:
        *letter = str->ob.str_8bit[pos];
        break;
    case 16:
        *letter = str->ob.str_16bit[pos];
        break;
    case 32:
        *letter = str->ob.str_32bit[pos];
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

/* Function to add a letter to the string. */
static bool
sfzcl_str_append_letter(SfzclStr str, uint32_t letter)
{
    if (str == NULL)
    {
        return FALSE;
    }

    /* Make sure there is always space for extra zero at the end of the
       string. */
    if (sfzcl_str_realloc(str, str->str_length + 2))
    {
        switch (str->bits)
        {
        case 8:
            if ((letter & 0xff00) != 0)
            {
                str->ob.str_8bit[str->str_length] = (letter >> 8) & 0xff;
                str->str_length++;
            }
            str->ob.str_8bit[str->str_length] = letter & 0xff;
            break;
        case 16:
            str->ob.str_16bit[str->str_length] = letter & 0xffff;
            break;
        case 32:
            str->ob.str_32bit[str->str_length] = letter;
            break;
        default:
            L_DEBUG(LF_TOTAL_PROGRESS,
                "Character set %u (%u bit chars) unsupported.",
                str->charset, str->bits);
            return FALSE;
        }
        str->str_length++;
        return TRUE;
    }
    return FALSE;
}

SfzclStr
sfzcl_str_allocate(SfzclCharset charset, size_t initial_memory)
{
    SfzclStr new_str = SPAL_Memory_Calloc(1, sizeof(*new_str));

    if (!new_str)
    {
        return NULL;
    }

    new_str->charset = charset;
    new_str->bits = 0;
    new_str->str_length = 0;
    new_str->mem_length = 0;

    switch (charset)
    {
    case SFZCL_CHARSET_PRINTABLE:
    case SFZCL_CHARSET_VISIBLE:
    case SFZCL_CHARSET_US_ASCII:
    case SFZCL_CHARSET_ISO_8859_1:
    case SFZCL_CHARSET_ISO_8859_2:
    case SFZCL_CHARSET_ISO_8859_3:
    case SFZCL_CHARSET_ISO_8859_4:
    case SFZCL_CHARSET_ISO_8859_15:
    case SFZCL_CHARSET_T61:
        /* Bit size. */
        new_str->bits = 8;

        if (initial_memory == 0)
        {
            break;
        }

        new_str->mem_length = initial_memory;
        if ((new_str->ob.str_8bit = SPAL_Memory_Alloc(initial_memory)) == NULL)
        {
            SPAL_Memory_Free(new_str);
            return NULL;
        }
        break;
    case SFZCL_CHARSET_BMP:
        /* Bit size. */
        new_str->bits = 16;

        if (initial_memory == 0)
        {
            break;
        }

        new_str->mem_length = initial_memory;
        if ((new_str->ob.str_16bit =
                 SPAL_Memory_Alloc(initial_memory * sizeof(uint16_t))) == NULL)
        {
            SPAL_Memory_Free(new_str);
            return NULL;
        }
        break;
    case SFZCL_CHARSET_UNIVERSAL:
    case SFZCL_CHARSET_UTF8:
        /* Bit size. */
        new_str->bits = 32;

        if (initial_memory == 0)
        {
            break;
        }

        new_str->mem_length = initial_memory;
        if ((new_str->ob.str_32bit =
                 SPAL_Memory_Alloc(initial_memory * sizeof(uint32_t))) == NULL)
        {
            SPAL_Memory_Free(new_str);
            return NULL;
        }
        break;
    default:
        L_DEBUG(LF_TOTAL_PROGRESS,
            "sfzcl_str_allocate: unknown character set %u.", charset);
        SPAL_Memory_Free(new_str);
        return NULL;

        /*sfzcl_fatal("sfzcl_str_allocate: unknown character set %u.", charset);
           break; */
    }
    return new_str;
}

unsigned char *
sfzcl_str_get_data(SfzclStr in_str, size_t *out_str_length)
{
    unsigned char *out_str = NULL;

    if (in_str == NULL)
    {
        return NULL;
    }

    switch (in_str->bits)
    {
    case 8:
        out_str = in_str->ob.str_8bit;
        *out_str_length = in_str->str_length;
        break;

    default:
        L_DEBUG(LF_TOTAL_PROGRESS, "sfzcl_str_get_data: "
            "cannot convert directly %u bit letters (charset %u) to "
            "'unsigned char' type.", in_str->bits, in_str->charset);

        return NULL;

        /*sfzcl_fatal("sfzcl_str_get_data: "
           "cannot convert directly %u bit letters (charset %u) to "
           "'unsigned char' type.", in_str->bits, in_str->charset);
           break; */
    }
    return out_str;
}

/* Free the actual data. */
void
sfzcl_str_free(SfzclStr str)
{
    if (str == NULL)
    {
        return;
    }
    switch (str->bits)
    {
    case 8:
        SPAL_Memory_Free(str->ob.str_8bit);
        break;
    case 16:
        SPAL_Memory_Free(str->ob.str_16bit);
        break;
    case 32:
        SPAL_Memory_Free(str->ob.str_32bit);
        break;
    default:
        L_DEBUG(LF_TOTAL_PROGRESS, "unknown %d bit char set.", str->bits);
        /*sfzcl_fatal("unknown %d bit char set.", str->bits); */
        break;
    }
    SPAL_Memory_Free(str);
}

/* This function frees the wrapper data structure only, not the
   underlying string. */
void
sfzcl_str_free_wrapper(SfzclStr str)
{
    if (str == NULL)
    {
        return;
    }
    SPAL_Memory_Free(str);
}

/* Tables:

   These tables are given to convert some particular set of characters
   from 8-bit to 16-bit BMP set. This mapping might not always be
   exactly correct. However, it is assumed that not all features of
   some exotic character sets are used by the application.

   0xffff denotes unsupported letter.

   Some of the space could be saved with more careful analysis of the
   contents of the tables. That might even speed up the searching a
   bit. */

typedef struct
{
    uint16_t unicode;
    uint16_t mapped;
} SfzclCharsetMap;

static const SfzclCharsetMap sfzcl_charset_printable_string_map[] = {
    { 0x0020, 0x0020 }, { 0x0027, 0x0027 }, { 0x0028, 0x0028 }, { 0x0029, 0x0029 },
    { 0x002b, 0x002b }, { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e },
    { 0x002f, 0x002f }, { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 },
    { 0x0033, 0x0033 }, { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 },
    { 0x0037, 0x0037 }, { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a },
    { 0x003d, 0x003d }, { 0x003f, 0x003f }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 },
    { 0x0043, 0x0043 }, { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 },
    { 0x0047, 0x0047 }, { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a },
    { 0x004b, 0x004b }, { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e },
    { 0x004f, 0x004f }, { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 },
    { 0x0053, 0x0053 }, { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 },
    { 0x0057, 0x0057 }, { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a },
    { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 }, { 0x0064, 0x0064 },
    { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 }, { 0x0068, 0x0068 },
    { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b }, { 0x006c, 0x006c },
    { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f }, { 0x0070, 0x0070 },
    { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 }, { 0x0074, 0x0074 },
    { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 }, { 0x0078, 0x0078 },
    { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0xffff, 0x001f }, { 0xffff, 0x0000 },
    { 0xffff, 0x0021 }, { 0xffff, 0x0022 }, { 0xffff, 0x0023 }, { 0xffff, 0x0024 },
    { 0xffff, 0x0025 }, { 0xffff, 0x0026 }, { 0xffff, 0x0001 }, { 0xffff, 0x0002 },
    { 0xffff, 0x0003 }, { 0xffff, 0x002a }, { 0xffff, 0x0004 }, { 0xffff, 0x0005 },
    { 0xffff, 0x0006 }, { 0xffff, 0x0007 }, { 0xffff, 0x0008 }, { 0xffff, 0x005b },
    { 0xffff, 0x005c }, { 0xffff, 0x005d }, { 0xffff, 0x005e }, { 0xffff, 0x005f },
    { 0xffff, 0x0060 }, { 0xffff, 0x0009 }, { 0xffff, 0x000a }, { 0xffff, 0x000b },
    { 0xffff, 0x000c }, { 0xffff, 0x000d }, { 0xffff, 0x000e }, { 0xffff, 0x000f },
    { 0xffff, 0x0010 }, { 0xffff, 0x0011 }, { 0xffff, 0x0012 }, { 0xffff, 0x0013 },
    { 0xffff, 0x003b }, { 0xffff, 0x003c }, { 0xffff, 0x0014 }, { 0xffff, 0x003e },
    { 0xffff, 0x0015 }, { 0xffff, 0x0040 }, { 0xffff, 0x0016 }, { 0xffff, 0x0017 },
    { 0xffff, 0x0018 }, { 0xffff, 0x0019 }, { 0xffff, 0x001a }, { 0xffff, 0x001b },
    { 0xffff, 0x001c }, { 0xffff, 0x001d }, { 0xffff, 0x001e }, { 0xffff, 0x007b },
    { 0xffff, 0x007c }, { 0xffff, 0x007d }, { 0xffff, 0x007e }, { 0xffff, 0x007f }
};

/* ISO 646 basic 1983 (used with VisibleStrings) */

static const uint16_t sfzcl_charset_visible[] = {
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0x0020, 0x0021, 0x0022, 0xffff, 0xffff, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0xffff, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0xffff, 0xffff, 0xffff, 0xffff, 0x005f,
    0xffff, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
};

static const SfzclCharsetMap sfzcl_charset_visible_map[] = {
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0025, 0x0025 },
    { 0x0026, 0x0026 }, { 0x0027, 0x0027 }, { 0x0028, 0x0028 }, { 0x0029, 0x0029 },
    { 0x002a, 0x002a }, { 0x002b, 0x002b }, { 0x002c, 0x002c }, { 0x002d, 0x002d },
    { 0x002e, 0x002e }, { 0x002f, 0x002f }, { 0x0030, 0x0030 }, { 0x0031, 0x0031 },
    { 0x0032, 0x0032 }, { 0x0033, 0x0033 }, { 0x0034, 0x0034 }, { 0x0035, 0x0035 },
    { 0x0036, 0x0036 }, { 0x0037, 0x0037 }, { 0x0038, 0x0038 }, { 0x0039, 0x0039 },
    { 0x003a, 0x003a }, { 0x003b, 0x003b }, { 0x003c, 0x003c }, { 0x003d, 0x003d },
    { 0x003e, 0x003e }, { 0x003f, 0x003f }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 },
    { 0x0043, 0x0043 }, { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 },
    { 0x0047, 0x0047 }, { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a },
    { 0x004b, 0x004b }, { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e },
    { 0x004f, 0x004f }, { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 },
    { 0x0053, 0x0053 }, { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 },
    { 0x0057, 0x0057 }, { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a },
    { 0x005f, 0x005f }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0xffff, 0x000e },
    { 0xffff, 0x000f }, { 0xffff, 0x0010 }, { 0xffff, 0x0011 }, { 0xffff, 0x0012 },
    { 0xffff, 0x0013 }, { 0xffff, 0x0014 }, { 0xffff, 0x0015 }, { 0xffff, 0x005b },
    { 0xffff, 0x005c }, { 0xffff, 0x005d }, { 0xffff, 0x005e }, { 0xffff, 0x0016 },
    { 0xffff, 0x0060 }, { 0xffff, 0x0017 }, { 0xffff, 0x0018 }, { 0xffff, 0x0019 },
    { 0xffff, 0x001a }, { 0xffff, 0x001b }, { 0xffff, 0x001c }, { 0xffff, 0x001d },
    { 0xffff, 0x0040 }, { 0xffff, 0x001e }, { 0xffff, 0x001f }, { 0xffff, 0x0000 },
    { 0xffff, 0x0001 }, { 0xffff, 0x0002 }, { 0xffff, 0x0023 }, { 0xffff, 0x0024 },
    { 0xffff, 0x0003 }, { 0xffff, 0x0004 }, { 0xffff, 0x0005 }, { 0xffff, 0x0006 },
    { 0xffff, 0x0007 }, { 0xffff, 0x0008 }, { 0xffff, 0x0009 }, { 0xffff, 0x000a },
    { 0xffff, 0x000b }, { 0xffff, 0x000c }, { 0xffff, 0x000d }, { 0xffff, 0x007b },
    { 0xffff, 0x007c }, { 0xffff, 0x007d }, { 0xffff, 0x007e }, { 0xffff, 0x007f }
};

/* ISO/IEC 6937:1994, T.61 or Teletext character map. */
static const SfzclCharsetMap sfzcl_charset_t61_unicode_map[] = {
    { 0x0000, 0x0000 }, { 0x0001, 0x0001 }, { 0x0002, 0x0002 }, { 0x0003, 0x0003 },
    { 0x0004, 0x0004 }, { 0x0005, 0x0005 }, { 0x0006, 0x0006 }, { 0x0007, 0x0007 },
    { 0x0008, 0x0008 }, { 0x0009, 0x0009 }, { 0x000a, 0x000a }, { 0x000b, 0x000b },
    { 0x000c, 0x000c }, { 0x000d, 0x000d }, { 0x000e, 0x000e }, { 0x000f, 0x000f },
    { 0x0010, 0x0010 }, { 0x0011, 0x0011 }, { 0x0012, 0x0012 }, { 0x0013, 0x0013 },
    { 0x0014, 0x0014 }, { 0x0015, 0x0015 }, { 0x0016, 0x0016 }, { 0x0017, 0x0017 },
    { 0x0018, 0x0018 }, { 0x0019, 0x0019 }, { 0x001a, 0x001a }, { 0x001b, 0x001b },
    { 0x001c, 0x001c }, { 0x001d, 0x001d }, { 0x001e, 0x001e }, { 0x001f, 0x001f },
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0023, 0x0023 },
    { 0x0024, 0x00a4 }, { 0x0025, 0x0025 }, { 0x0026, 0x0026 }, { 0x0027, 0x0027 },
    { 0x0028, 0x0028 }, { 0x0029, 0x0029 }, { 0x002a, 0x002a }, { 0x002b, 0x002b },
    { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e }, { 0x002f, 0x002f },
    { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 }, { 0x0033, 0x0033 },
    { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 }, { 0x0037, 0x0037 },
    { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a }, { 0x003b, 0x003b },
    { 0x003c, 0x003c }, { 0x003d, 0x003d }, { 0x003e, 0x003e }, { 0x003f, 0x003f },
    { 0x0040, 0x0040 }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 }, { 0x0043, 0x0043 },
    { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 }, { 0x0047, 0x0047 },
    { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a }, { 0x004b, 0x004b },
    { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e }, { 0x004f, 0x004f },
    { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 }, { 0x0053, 0x0053 },
    { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 }, { 0x0057, 0x0057 },
    { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a }, { 0x005b, 0x005b },
    { 0x005c, 0x005c }, { 0x005d, 0x005d }, { 0x005e, 0x005e }, { 0x005f, 0x005f },
    { 0x0060, 0x0060 }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0x007b, 0x007b },
    { 0x007c, 0x007c }, { 0x007d, 0x007d }, { 0x007e, 0x007e }, { 0x007f, 0x007f },
    { 0x0080, 0x0080 }, { 0x0081, 0x0081 }, { 0x0082, 0x0082 }, { 0x0083, 0x0083 },
    { 0x0084, 0x0084 }, { 0x0085, 0x0085 }, { 0x0086, 0x0086 }, { 0x0087, 0x0087 },
    { 0x0088, 0x0088 }, { 0x0089, 0x0089 }, { 0x008a, 0x008a }, { 0x008b, 0x008b },
    { 0x008c, 0x008c }, { 0x008d, 0x008d }, { 0x008e, 0x008e }, { 0x008f, 0x008f },
    { 0x0090, 0x0090 }, { 0x0091, 0x0091 }, { 0x0092, 0x0092 }, { 0x0093, 0x0093 },
    { 0x0094, 0x0094 }, { 0x0095, 0x0095 }, { 0x0096, 0x0096 }, { 0x0097, 0x0097 },
    { 0x0098, 0x0098 }, { 0x0099, 0x0099 }, { 0x009a, 0x009a }, { 0x009b, 0x009b },
    { 0x009c, 0x009c }, { 0x009d, 0x009d }, { 0x009e, 0x009e }, { 0x009f, 0x009f },
    { 0x00a0, 0x00a0 }, { 0x00a1, 0x00a1 }, { 0x00a2, 0x00a2 }, { 0x00a3, 0x00a3 },
    { 0x00a4, 0x0024 }, { 0x00a5, 0x00a5 }, { 0x00a7, 0x00a7 }, { 0x00a9, 0x2018 },
    { 0x00aa, 0x201c }, { 0x00ab, 0x00ab }, { 0x00ac, 0x2190 }, { 0x00ad, 0x2191 },
    { 0x00ae, 0x2192 }, { 0x00af, 0x2193 }, { 0x00b0, 0x00b0 }, { 0x00b1, 0x00b1 },
    { 0x00b2, 0x00b2 }, { 0x00b3, 0x00b3 }, { 0x00b4, 0x00d7 }, { 0x00b5, 0x00b5 },
    { 0x00b6, 0x00b6 }, { 0x00b7, 0x00b7 }, { 0x00b8, 0x00f7 }, { 0x00b9, 0x2019 },
    { 0x00ba, 0x201d }, { 0x00bb, 0x00bb }, { 0x00bc, 0x00bc }, { 0x00bd, 0x00bd },
    { 0x00be, 0x00be }, { 0x00bf, 0x00bf }, { 0x00c1, 0xe002 }, { 0x00c2, 0xe003 },
    { 0x00c3, 0xe004 }, { 0x00c4, 0xe005 }, { 0x00c5, 0xe006 }, { 0x00c6, 0xe007 },
    { 0x00c7, 0xe008 }, { 0x00c8, 0xe009 }, { 0x00ca, 0xe00a }, { 0x00cb, 0xe00b },
    { 0x00cc, 0xe00c }, { 0x00cd, 0xe00d }, { 0x00ce, 0xe00e }, { 0x00cf, 0xe00f },
    { 0x00d0, 0x2014 }, { 0x00d1, 0x00b9 }, { 0x00d2, 0x00ae }, { 0x00d3, 0x00a9 },
    { 0x00d4, 0x2122 }, { 0x00d5, 0x266a }, { 0x00d6, 0x00ac }, { 0x00d7, 0x00a6 },
    { 0x00dc, 0x215b }, { 0x00dd, 0x215c }, { 0x00de, 0x215d }, { 0x00df, 0x215e },
    { 0x00e0, 0x2126 }, { 0x00e1, 0x00c6 }, { 0x00e2, 0x00d0 }, { 0x00e3, 0x00aa },
    { 0x00e4, 0x0126 }, { 0x00e6, 0x0132 }, { 0x00e7, 0x013f }, { 0x00e8, 0x0141 },
    { 0x00e9, 0x00d8 }, { 0x00ea, 0x0152 }, { 0x00eb, 0x00ba }, { 0x00ec, 0x00de },
    { 0x00ed, 0x0166 }, { 0x00ee, 0x014a }, { 0x00ef, 0x0149 }, { 0x00f0, 0x0138 },
    { 0x00f1, 0x00e6 }, { 0x00f2, 0x0111 }, { 0x00f3, 0x00f0 }, { 0x00f4, 0x0127 },
    { 0x00f5, 0x0131 }, { 0x00f6, 0x0133 }, { 0x00f7, 0x0140 }, { 0x00f8, 0x0142 },
    { 0x00f9, 0x00f8 }, { 0x00fa, 0x0153 }, { 0x00fb, 0x00df }, { 0x00fc, 0x00fe },
    { 0x00fd, 0x0167 }, { 0x00fe, 0x014b }, { 0x00ff, 0x00ad }, { 0xc141, 0x00c0 },
    { 0xc145, 0x00c8 }, { 0xc149, 0x00cc }, { 0xc14f, 0x00d2 }, { 0xc155, 0x00d9 },
    { 0xc161, 0x00e0 }, { 0xc165, 0x00e8 }, { 0xc169, 0x00ec }, { 0xc16f, 0x00f2 },
    { 0xc175, 0x00f9 }, { 0xc220, 0x00b4 }, { 0xc241, 0x00c1 }, { 0xc243, 0x0106 },
    { 0xc245, 0x00c9 }, { 0xc249, 0x00cd }, { 0xc24c, 0x0139 }, { 0xc24e, 0x0143 },
    { 0xc24f, 0x00d3 }, { 0xc252, 0x0154 }, { 0xc253, 0x015a }, { 0xc255, 0x00da },
    { 0xc259, 0x00dd }, { 0xc25a, 0x0179 }, { 0xc261, 0x00e1 }, { 0xc263, 0x0107 },
    { 0xc265, 0x00e9 }, { 0xc269, 0x00ed }, { 0xc26c, 0x013a }, { 0xc26e, 0x0144 },
    { 0xc26f, 0x00f3 }, { 0xc272, 0x0155 }, { 0xc273, 0x015b }, { 0xc275, 0x00fa },
    { 0xc279, 0x00fd }, { 0xc27a, 0x017a }, { 0xc341, 0x00c2 }, { 0xc343, 0x0108 },
    { 0xc345, 0x00ca }, { 0xc347, 0x011c }, { 0xc348, 0x0124 }, { 0xc349, 0x00ce },
    { 0xc34a, 0x0134 }, { 0xc34f, 0x00d4 }, { 0xc353, 0x015c }, { 0xc355, 0x00db },
    { 0xc357, 0x0174 }, { 0xc359, 0x0176 }, { 0xc361, 0x00e2 }, { 0xc363, 0x0109 },
    { 0xc365, 0x00ea }, { 0xc367, 0x011d }, { 0xc368, 0x0125 }, { 0xc369, 0x00ee },
    { 0xc36a, 0x0135 }, { 0xc36f, 0x00f4 }, { 0xc373, 0x015d }, { 0xc375, 0x00fb },
    { 0xc377, 0x0175 }, { 0xc379, 0x0177 }, { 0xc441, 0x00c3 }, { 0xc449, 0x0128 },
    { 0xc44e, 0x00d1 }, { 0xc44f, 0x00d5 }, { 0xc455, 0x0168 }, { 0xc461, 0x00e3 },
    { 0xc469, 0x0129 }, { 0xc46e, 0x00f1 }, { 0xc46f, 0x00f5 }, { 0xc475, 0x0169 },
    { 0xc520, 0x00af }, { 0xc541, 0x0100 }, { 0xc545, 0x0112 }, { 0xc549, 0x012a },
    { 0xc54f, 0x014c }, { 0xc555, 0x016a }, { 0xc561, 0x0101 }, { 0xc565, 0x0113 },
    { 0xc569, 0x012b }, { 0xc56f, 0x014d }, { 0xc575, 0x016b }, { 0xc620, 0x02d8 },
    { 0xc641, 0x0102 }, { 0xc647, 0x011e }, { 0xc655, 0x016c }, { 0xc661, 0x0103 },
    { 0xc667, 0x011f }, { 0xc675, 0x016d }, { 0xc720, 0x02d9 }, { 0xc743, 0x010a },
    { 0xc745, 0x0116 }, { 0xc747, 0x0120 }, { 0xc749, 0x0130 }, { 0xc75a, 0x017b },
    { 0xc763, 0x010b }, { 0xc765, 0x0117 }, { 0xc767, 0x0121 }, { 0xc77a, 0x017c },
    { 0xc820, 0x00a8 }, { 0xc841, 0x00c4 }, { 0xc845, 0x00cb }, { 0xc849, 0x00cf },
    { 0xc84f, 0x00d6 }, { 0xc855, 0x00dc }, { 0xc859, 0x0178 }, { 0xc861, 0x00e4 },
    { 0xc865, 0x00eb }, { 0xc869, 0x00ef }, { 0xc86f, 0x00f6 }, { 0xc875, 0x00fc },
    { 0xc879, 0x00ff }, { 0xca20, 0x02da }, { 0xca41, 0x00c5 }, { 0xca55, 0x016e },
    { 0xca61, 0x00e5 }, { 0xca75, 0x016f }, { 0xcb20, 0x00b8 }, { 0xcb43, 0x00c7 },
    { 0xcb47, 0x0122 }, { 0xcb4b, 0x0136 }, { 0xcb4c, 0x013b }, { 0xcb4e, 0x0145 },
    { 0xcb52, 0x0156 }, { 0xcb53, 0x015e }, { 0xcb54, 0x0162 }, { 0xcb63, 0x00e7 },
    { 0xcb67, 0x0123 }, { 0xcb6b, 0x0137 }, { 0xcb6c, 0x013c }, { 0xcb6e, 0x0146 },
    { 0xcb72, 0x0157 }, { 0xcb73, 0x015f }, { 0xcb74, 0x0163 }, { 0xcd20, 0x02dd },
    { 0xcd4f, 0x0150 }, { 0xcd55, 0x0170 }, { 0xcd6f, 0x0151 }, { 0xcd75, 0x0171 },
    { 0xce20, 0x02db }, { 0xce41, 0x0104 }, { 0xce45, 0x0118 }, { 0xce49, 0x012e },
    { 0xce55, 0x0172 }, { 0xce61, 0x0105 }, { 0xce65, 0x0119 }, { 0xce69, 0x012f },
    { 0xce75, 0x0173 }, { 0xcf20, 0x02c7 }, { 0xcf43, 0x010c }, { 0xcf44, 0x010e },
    { 0xcf45, 0x011a }, { 0xcf4c, 0x013d }, { 0xcf4e, 0x0147 }, { 0xcf52, 0x0158 },
    { 0xcf53, 0x0160 }, { 0xcf54, 0x0164 }, { 0xcf5a, 0x017d }, { 0xcf63, 0x010d },
    { 0xcf64, 0x010f }, { 0xcf65, 0x011b }, { 0xcf6c, 0x013e }, { 0xcf6e, 0x0148 },
    { 0xcf72, 0x0159 }, { 0xcf73, 0x0161 }, { 0xcf74, 0x0165 }, { 0xcf7a, 0x017e },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
};

static const SfzclCharsetMap sfzcl_charset_t61_map[] = {
    { 0x0000, 0x0000 }, { 0x0001, 0x0001 }, { 0x0002, 0x0002 }, { 0x0003, 0x0003 },
    { 0x0004, 0x0004 }, { 0x0005, 0x0005 }, { 0x0006, 0x0006 }, { 0x0007, 0x0007 },
    { 0x0008, 0x0008 }, { 0x0009, 0x0009 }, { 0x000a, 0x000a }, { 0x000b, 0x000b },
    { 0x000c, 0x000c }, { 0x000d, 0x000d }, { 0x000e, 0x000e }, { 0x000f, 0x000f },
    { 0x0010, 0x0010 }, { 0x0011, 0x0011 }, { 0x0012, 0x0012 }, { 0x0013, 0x0013 },
    { 0x0014, 0x0014 }, { 0x0015, 0x0015 }, { 0x0016, 0x0016 }, { 0x0017, 0x0017 },
    { 0x0018, 0x0018 }, { 0x0019, 0x0019 }, { 0x001a, 0x001a }, { 0x001b, 0x001b },
    { 0x001c, 0x001c }, { 0x001d, 0x001d }, { 0x001e, 0x001e }, { 0x001f, 0x001f },
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0023, 0x0023 },
    { 0x0024, 0x00a4 }, { 0x0025, 0x0025 }, { 0x0026, 0x0026 }, { 0x0027, 0x0027 },
    { 0x0028, 0x0028 }, { 0x0029, 0x0029 }, { 0x002a, 0x002a }, { 0x002b, 0x002b },
    { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e }, { 0x002f, 0x002f },
    { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 }, { 0x0033, 0x0033 },
    { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 }, { 0x0037, 0x0037 },
    { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a }, { 0x003b, 0x003b },
    { 0x003c, 0x003c }, { 0x003d, 0x003d }, { 0x003e, 0x003e }, { 0x003f, 0x003f },
    { 0x0040, 0x0040 }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 }, { 0x0043, 0x0043 },
    { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 }, { 0x0047, 0x0047 },
    { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a }, { 0x004b, 0x004b },
    { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e }, { 0x004f, 0x004f },
    { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 }, { 0x0053, 0x0053 },
    { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 }, { 0x0057, 0x0057 },
    { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a }, { 0x005b, 0x005b },
    { 0x005c, 0x005c }, { 0x005d, 0x005d }, { 0x005e, 0x005e }, { 0x005f, 0x005f },
    { 0x0060, 0x0060 }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0x007b, 0x007b },
    { 0x007c, 0x007c }, { 0x007d, 0x007d }, { 0x007e, 0x007e }, { 0x007f, 0x007f },
    { 0x0080, 0x0080 }, { 0x0081, 0x0081 }, { 0x0082, 0x0082 }, { 0x0083, 0x0083 },
    { 0x0084, 0x0084 }, { 0x0085, 0x0085 }, { 0x0086, 0x0086 }, { 0x0087, 0x0087 },
    { 0x0088, 0x0088 }, { 0x0089, 0x0089 }, { 0x008a, 0x008a }, { 0x008b, 0x008b },
    { 0x008c, 0x008c }, { 0x008d, 0x008d }, { 0x008e, 0x008e }, { 0x008f, 0x008f },
    { 0x0090, 0x0090 }, { 0x0091, 0x0091 }, { 0x0092, 0x0092 }, { 0x0093, 0x0093 },
    { 0x0094, 0x0094 }, { 0x0095, 0x0095 }, { 0x0096, 0x0096 }, { 0x0097, 0x0097 },
    { 0x0098, 0x0098 }, { 0x0099, 0x0099 }, { 0x009a, 0x009a }, { 0x009b, 0x009b },
    { 0x009c, 0x009c }, { 0x009d, 0x009d }, { 0x009e, 0x009e }, { 0x009f, 0x009f },
    { 0x00a0, 0x00a0 }, { 0x00a1, 0x00a1 }, { 0x00a2, 0x00a2 }, { 0x00a3, 0x00a3 },
    { 0x00a4, 0x0024 }, { 0x00a5, 0x00a5 }, { 0x00a6, 0x00d7 }, { 0x00a7, 0x00a7 },
    { 0x00a8, 0xc820 }, { 0x00a9, 0x00d3 }, { 0x00aa, 0x00e3 }, { 0x00ab, 0x00ab },
    { 0x00ac, 0x00d6 }, { 0x00ad, 0x00ff }, { 0x00ae, 0x00d2 }, { 0x00af, 0xc520 },
    { 0x00b0, 0x00b0 }, { 0x00b1, 0x00b1 }, { 0x00b2, 0x00b2 }, { 0x00b3, 0x00b3 },
    { 0x00b4, 0xc220 }, { 0x00b5, 0x00b5 }, { 0x00b6, 0x00b6 }, { 0x00b7, 0x00b7 },
    { 0x00b8, 0xcb20 }, { 0x00b9, 0x00d1 }, { 0x00ba, 0x00eb }, { 0x00bb, 0x00bb },
    { 0x00bc, 0x00bc }, { 0x00bd, 0x00bd }, { 0x00be, 0x00be }, { 0x00bf, 0x00bf },
    { 0x00c0, 0xc141 }, { 0x00c1, 0xc241 }, { 0x00c2, 0xc341 }, { 0x00c3, 0xc441 },
    { 0x00c4, 0xc841 }, { 0x00c5, 0xca41 }, { 0x00c6, 0x00e1 }, { 0x00c7, 0xcb43 },
    { 0x00c8, 0xc145 }, { 0x00c9, 0xc245 }, { 0x00ca, 0xc345 }, { 0x00cb, 0xc845 },
    { 0x00cc, 0xc149 }, { 0x00cd, 0xc249 }, { 0x00ce, 0xc349 }, { 0x00cf, 0xc849 },
    { 0x00d0, 0x00e2 }, { 0x00d1, 0xc44e }, { 0x00d2, 0xc14f }, { 0x00d3, 0xc24f },
    { 0x00d4, 0xc34f }, { 0x00d5, 0xc44f }, { 0x00d6, 0xc84f }, { 0x00d7, 0x00b4 },
    { 0x00d8, 0x00e9 }, { 0x00d9, 0xc155 }, { 0x00da, 0xc255 }, { 0x00db, 0xc355 },
    { 0x00dc, 0xc855 }, { 0x00dd, 0xc259 }, { 0x00de, 0x00ec }, { 0x00df, 0x00fb },
    { 0x00e0, 0xc161 }, { 0x00e1, 0xc261 }, { 0x00e2, 0xc361 }, { 0x00e3, 0xc461 },
    { 0x00e4, 0xc861 }, { 0x00e5, 0xca61 }, { 0x00e6, 0x00f1 }, { 0x00e7, 0xcb63 },
    { 0x00e8, 0xc165 }, { 0x00e9, 0xc265 }, { 0x00ea, 0xc365 }, { 0x00eb, 0xc865 },
    { 0x00ec, 0xc169 }, { 0x00ed, 0xc269 }, { 0x00ee, 0xc369 }, { 0x00ef, 0xc869 },
    { 0x00f0, 0x00f3 }, { 0x00f1, 0xc46e }, { 0x00f2, 0xc16f }, { 0x00f3, 0xc26f },
    { 0x00f4, 0xc36f }, { 0x00f5, 0xc46f }, { 0x00f6, 0xc86f }, { 0x00f7, 0x00b8 },
    { 0x00f8, 0x00f9 }, { 0x00f9, 0xc175 }, { 0x00fa, 0xc275 }, { 0x00fb, 0xc375 },
    { 0x00fc, 0xc875 }, { 0x00fd, 0xc279 }, { 0x00fe, 0x00fc }, { 0x00ff, 0xc879 },
    { 0x0100, 0xc541 }, { 0x0101, 0xc561 }, { 0x0102, 0xc641 }, { 0x0103, 0xc661 },
    { 0x0104, 0xce41 }, { 0x0105, 0xce61 }, { 0x0106, 0xc243 }, { 0x0107, 0xc263 },
    { 0x0108, 0xc343 }, { 0x0109, 0xc363 }, { 0x010a, 0xc743 }, { 0x010b, 0xc763 },
    { 0x010c, 0xcf43 }, { 0x010d, 0xcf63 }, { 0x010e, 0xcf44 }, { 0x010f, 0xcf64 },
    { 0x0111, 0x00f2 }, { 0x0112, 0xc545 }, { 0x0113, 0xc565 }, { 0x0116, 0xc745 },
    { 0x0117, 0xc765 }, { 0x0118, 0xce45 }, { 0x0119, 0xce65 }, { 0x011a, 0xcf45 },
    { 0x011b, 0xcf65 }, { 0x011c, 0xc347 }, { 0x011d, 0xc367 }, { 0x011e, 0xc647 },
    { 0x011f, 0xc667 }, { 0x0120, 0xc747 }, { 0x0121, 0xc767 }, { 0x0122, 0xcb47 },
    { 0x0123, 0xcb67 }, { 0x0124, 0xc348 }, { 0x0125, 0xc368 }, { 0x0126, 0x00e4 },
    { 0x0127, 0x00f4 }, { 0x0128, 0xc449 }, { 0x0129, 0xc469 }, { 0x012a, 0xc549 },
    { 0x012b, 0xc569 }, { 0x012e, 0xce49 }, { 0x012f, 0xce69 }, { 0x0130, 0xc749 },
    { 0x0131, 0x00f5 }, { 0x0132, 0x00e6 }, { 0x0133, 0x00f6 }, { 0x0134, 0xc34a },
    { 0x0135, 0xc36a }, { 0x0136, 0xcb4b }, { 0x0137, 0xcb6b }, { 0x0138, 0x00f0 },
    { 0x0139, 0xc24c }, { 0x013a, 0xc26c }, { 0x013b, 0xcb4c }, { 0x013c, 0xcb6c },
    { 0x013d, 0xcf4c }, { 0x013e, 0xcf6c }, { 0x013f, 0x00e7 }, { 0x0140, 0x00f7 },
    { 0x0141, 0x00e8 }, { 0x0142, 0x00f8 }, { 0x0143, 0xc24e }, { 0x0144, 0xc26e },
    { 0x0145, 0xcb4e }, { 0x0146, 0xcb6e }, { 0x0147, 0xcf4e }, { 0x0148, 0xcf6e },
    { 0x0149, 0x00ef }, { 0x014a, 0x00ee }, { 0x014b, 0x00fe }, { 0x014c, 0xc54f },
    { 0x014d, 0xc56f }, { 0x0150, 0xcd4f }, { 0x0151, 0xcd6f }, { 0x0152, 0x00ea },
    { 0x0153, 0x00fa }, { 0x0154, 0xc252 }, { 0x0155, 0xc272 }, { 0x0156, 0xcb52 },
    { 0x0157, 0xcb72 }, { 0x0158, 0xcf52 }, { 0x0159, 0xcf72 }, { 0x015a, 0xc253 },
    { 0x015b, 0xc273 }, { 0x015c, 0xc353 }, { 0x015d, 0xc373 }, { 0x015e, 0xcb53 },
    { 0x015f, 0xcb73 }, { 0x0160, 0xcf53 }, { 0x0161, 0xcf73 }, { 0x0162, 0xcb54 },
    { 0x0163, 0xcb74 }, { 0x0164, 0xcf54 }, { 0x0165, 0xcf74 }, { 0x0166, 0x00ed },
    { 0x0167, 0x00fd }, { 0x0168, 0xc455 }, { 0x0169, 0xc475 }, { 0x016a, 0xc555 },
    { 0x016b, 0xc575 }, { 0x016c, 0xc655 }, { 0x016d, 0xc675 }, { 0x016e, 0xca55 },
    { 0x016f, 0xca75 }, { 0x0170, 0xcd55 }, { 0x0171, 0xcd75 }, { 0x0172, 0xce55 },
    { 0x0173, 0xce75 }, { 0x0174, 0xc357 }, { 0x0175, 0xc377 }, { 0x0176, 0xc359 },
    { 0x0177, 0xc379 }, { 0x0178, 0xc859 }, { 0x0179, 0xc25a }, { 0x017a, 0xc27a },
    { 0x017b, 0xc75a }, { 0x017c, 0xc77a }, { 0x017d, 0xcf5a }, { 0x017e, 0xcf7a },
    { 0x02c7, 0xcf20 }, { 0x02d8, 0xc620 }, { 0x02d9, 0xc720 }, { 0x02da, 0xca20 },
    { 0x02db, 0xce20 }, { 0x02dd, 0xcd20 }, { 0x2014, 0x00d0 }, { 0x2018, 0x00a9 },
    { 0x2019, 0x00b9 }, { 0x201c, 0x00aa }, { 0x201d, 0x00ba }, { 0x2122, 0x00d4 },
    { 0x2126, 0x00e0 }, { 0x215b, 0x00dc }, { 0x215c, 0x00dd }, { 0x215d, 0x00de },
    { 0x215e, 0x00df }, { 0x2190, 0x00ac }, { 0x2191, 0x00ad }, { 0x2192, 0x00ae },
    { 0x2193, 0x00af }, { 0x266a, 0x00d5 }, { 0xe002, 0x00c1 }, { 0xe003, 0x00c2 },
    { 0xe004, 0x00c3 }, { 0xe005, 0x00c4 }, { 0xe006, 0x00c5 }, { 0xe007, 0x00c6 },
    { 0xe008, 0x00c7 }, { 0xe009, 0x00c8 }, { 0xe00a, 0x00ca }, { 0xe00b, 0x00cb },
    { 0xe00c, 0x00cc }, { 0xe00d, 0x00cd }, { 0xe00e, 0x00ce }, { 0xe00f, 0x00cf },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
    { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff }, { 0xffff, 0xffff },
};

#ifdef USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER
/* ISO 8859-2:1987 character set. */
static const uint16_t sfzcl_charset_iso_8859_2[] = {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7,
    0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,
    0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7,
    0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,
    0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,
    0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,
    0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,
    0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,
    0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,
    0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,
    0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,
    0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9
};

static const SfzclCharsetMap sfzcl_charset_iso_8859_2_map[] = {
    { 0x0000, 0x0000 }, { 0x0001, 0x0001 }, { 0x0002, 0x0002 }, { 0x0003, 0x0003 },
    { 0x0004, 0x0004 }, { 0x0005, 0x0005 }, { 0x0006, 0x0006 }, { 0x0007, 0x0007 },
    { 0x0008, 0x0008 }, { 0x0009, 0x0009 }, { 0x000a, 0x000a }, { 0x000b, 0x000b },
    { 0x000c, 0x000c }, { 0x000d, 0x000d }, { 0x000e, 0x000e }, { 0x000f, 0x000f },
    { 0x0010, 0x0010 }, { 0x0011, 0x0011 }, { 0x0012, 0x0012 }, { 0x0013, 0x0013 },
    { 0x0014, 0x0014 }, { 0x0015, 0x0015 }, { 0x0016, 0x0016 }, { 0x0017, 0x0017 },
    { 0x0018, 0x0018 }, { 0x0019, 0x0019 }, { 0x001a, 0x001a }, { 0x001b, 0x001b },
    { 0x001c, 0x001c }, { 0x001d, 0x001d }, { 0x001e, 0x001e }, { 0x001f, 0x001f },
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0023, 0x0023 },
    { 0x0024, 0x0024 }, { 0x0025, 0x0025 }, { 0x0026, 0x0026 }, { 0x0027, 0x0027 },
    { 0x0028, 0x0028 }, { 0x0029, 0x0029 }, { 0x002a, 0x002a }, { 0x002b, 0x002b },
    { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e }, { 0x002f, 0x002f },
    { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 }, { 0x0033, 0x0033 },
    { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 }, { 0x0037, 0x0037 },
    { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a }, { 0x003b, 0x003b },
    { 0x003c, 0x003c }, { 0x003d, 0x003d }, { 0x003e, 0x003e }, { 0x003f, 0x003f },
    { 0x0040, 0x0040 }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 }, { 0x0043, 0x0043 },
    { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 }, { 0x0047, 0x0047 },
    { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a }, { 0x004b, 0x004b },
    { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e }, { 0x004f, 0x004f },
    { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 }, { 0x0053, 0x0053 },
    { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 }, { 0x0057, 0x0057 },
    { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a }, { 0x005b, 0x005b },
    { 0x005c, 0x005c }, { 0x005d, 0x005d }, { 0x005e, 0x005e }, { 0x005f, 0x005f },
    { 0x0060, 0x0060 }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0x007b, 0x007b },
    { 0x007c, 0x007c }, { 0x007d, 0x007d }, { 0x007e, 0x007e }, { 0x007f, 0x007f },
    { 0x0080, 0x0080 }, { 0x0081, 0x0081 }, { 0x0082, 0x0082 }, { 0x0083, 0x0083 },
    { 0x0084, 0x0084 }, { 0x0085, 0x0085 }, { 0x0086, 0x0086 }, { 0x0087, 0x0087 },
    { 0x0088, 0x0088 }, { 0x0089, 0x0089 }, { 0x008a, 0x008a }, { 0x008b, 0x008b },
    { 0x008c, 0x008c }, { 0x008d, 0x008d }, { 0x008e, 0x008e }, { 0x008f, 0x008f },
    { 0x0090, 0x0090 }, { 0x0091, 0x0091 }, { 0x0092, 0x0092 }, { 0x0093, 0x0093 },
    { 0x0094, 0x0094 }, { 0x0095, 0x0095 }, { 0x0096, 0x0096 }, { 0x0097, 0x0097 },
    { 0x0098, 0x0098 }, { 0x0099, 0x0099 }, { 0x009a, 0x009a }, { 0x009b, 0x009b },
    { 0x009c, 0x009c }, { 0x009d, 0x009d }, { 0x009e, 0x009e }, { 0x009f, 0x009f },
    { 0x00a0, 0x00a0 }, { 0x00a4, 0x00a4 }, { 0x00a7, 0x00a7 }, { 0x00a8, 0x00a8 },
    { 0x00ad, 0x00ad }, { 0x00b0, 0x00b0 }, { 0x00b4, 0x00b4 }, { 0x00b8, 0x00b8 },
    { 0x00c1, 0x00c1 }, { 0x00c2, 0x00c2 }, { 0x00c4, 0x00c4 }, { 0x00c7, 0x00c7 },
    { 0x00c9, 0x00c9 }, { 0x00cb, 0x00cb }, { 0x00cd, 0x00cd }, { 0x00ce, 0x00ce },
    { 0x00d3, 0x00d3 }, { 0x00d4, 0x00d4 }, { 0x00d6, 0x00d6 }, { 0x00d7, 0x00d7 },
    { 0x00da, 0x00da }, { 0x00dc, 0x00dc }, { 0x00dd, 0x00dd }, { 0x00df, 0x00df },
    { 0x00e1, 0x00e1 }, { 0x00e2, 0x00e2 }, { 0x00e4, 0x00e4 }, { 0x00e7, 0x00e7 },
    { 0x00e9, 0x00e9 }, { 0x00eb, 0x00eb }, { 0x00ed, 0x00ed }, { 0x00ee, 0x00ee },
    { 0x00f3, 0x00f3 }, { 0x00f4, 0x00f4 }, { 0x00f6, 0x00f6 }, { 0x00f7, 0x00f7 },
    { 0x00fa, 0x00fa }, { 0x00fc, 0x00fc }, { 0x00fd, 0x00fd }, { 0x0102, 0x00c3 },
    { 0x0103, 0x00e3 }, { 0x0104, 0x00a1 }, { 0x0105, 0x00b1 }, { 0x0106, 0x00c6 },
    { 0x0107, 0x00e6 }, { 0x010c, 0x00c8 }, { 0x010d, 0x00e8 }, { 0x010e, 0x00cf },
    { 0x010f, 0x00ef }, { 0x0110, 0x00d0 }, { 0x0111, 0x00f0 }, { 0x0118, 0x00ca },
    { 0x0119, 0x00ea }, { 0x011a, 0x00cc }, { 0x011b, 0x00ec }, { 0x0139, 0x00c5 },
    { 0x013a, 0x00e5 }, { 0x013d, 0x00a5 }, { 0x013e, 0x00b5 }, { 0x0141, 0x00a3 },
    { 0x0142, 0x00b3 }, { 0x0143, 0x00d1 }, { 0x0144, 0x00f1 }, { 0x0147, 0x00d2 },
    { 0x0148, 0x00f2 }, { 0x0150, 0x00d5 }, { 0x0151, 0x00f5 }, { 0x0154, 0x00c0 },
    { 0x0155, 0x00e0 }, { 0x0158, 0x00d8 }, { 0x0159, 0x00f8 }, { 0x015a, 0x00a6 },
    { 0x015b, 0x00b6 }, { 0x015e, 0x00aa }, { 0x015f, 0x00ba }, { 0x0160, 0x00a9 },
    { 0x0161, 0x00b9 }, { 0x0162, 0x00de }, { 0x0163, 0x00fe }, { 0x0164, 0x00ab },
    { 0x0165, 0x00bb }, { 0x016e, 0x00d9 }, { 0x016f, 0x00f9 }, { 0x0170, 0x00db },
    { 0x0171, 0x00fb }, { 0x0179, 0x00ac }, { 0x017a, 0x00bc }, { 0x017b, 0x00af },
    { 0x017c, 0x00bf }, { 0x017d, 0x00ae }, { 0x017e, 0x00be }, { 0x02c7, 0x00b7 },
    { 0x02d8, 0x00a2 }, { 0x02d9, 0x00ff }, { 0x02db, 0x00b2 }, { 0x02dd, 0x00bd }
};
#endif /* USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER */

/* ISO 8859-3:1988 character set. */

#ifdef USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER
static const uint16_t sfzcl_charset_iso_8859_3[] = {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4, 0xffff, 0x0124, 0x00a7,
    0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0xffff, 0x017b,
    0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7,
    0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd, 0xffff, 0x017c,
    0x00c0, 0x00c1, 0x00c2, 0xffff, 0x00c4, 0x010a, 0x0108, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
    0xffff, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7,
    0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,
    0x00e0, 0x00e1, 0x00e2, 0xffff, 0x00e4, 0x010b, 0x0109, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
    0xffff, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7,
    0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9
};

static const SfzclCharsetMap sfzcl_charset_iso_8859_3_map[] = {
    { 0x0000, 0x0000 }, { 0x0001, 0x0001 }, { 0x0002, 0x0002 }, { 0x0003, 0x0003 },
    { 0x0004, 0x0004 }, { 0x0005, 0x0005 }, { 0x0006, 0x0006 }, { 0x0007, 0x0007 },
    { 0x0008, 0x0008 }, { 0x0009, 0x0009 }, { 0x000a, 0x000a }, { 0x000b, 0x000b },
    { 0x000c, 0x000c }, { 0x000d, 0x000d }, { 0x000e, 0x000e }, { 0x000f, 0x000f },
    { 0x0010, 0x0010 }, { 0x0011, 0x0011 }, { 0x0012, 0x0012 }, { 0x0013, 0x0013 },
    { 0x0014, 0x0014 }, { 0x0015, 0x0015 }, { 0x0016, 0x0016 }, { 0x0017, 0x0017 },
    { 0x0018, 0x0018 }, { 0x0019, 0x0019 }, { 0x001a, 0x001a }, { 0x001b, 0x001b },
    { 0x001c, 0x001c }, { 0x001d, 0x001d }, { 0x001e, 0x001e }, { 0x001f, 0x001f },
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0023, 0x0023 },
    { 0x0024, 0x0024 }, { 0x0025, 0x0025 }, { 0x0026, 0x0026 }, { 0x0027, 0x0027 },
    { 0x0028, 0x0028 }, { 0x0029, 0x0029 }, { 0x002a, 0x002a }, { 0x002b, 0x002b },
    { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e }, { 0x002f, 0x002f },
    { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 }, { 0x0033, 0x0033 },
    { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 }, { 0x0037, 0x0037 },
    { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a }, { 0x003b, 0x003b },
    { 0x003c, 0x003c }, { 0x003d, 0x003d }, { 0x003e, 0x003e }, { 0x003f, 0x003f },
    { 0x0040, 0x0040 }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 }, { 0x0043, 0x0043 },
    { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 }, { 0x0047, 0x0047 },
    { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a }, { 0x004b, 0x004b },
    { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e }, { 0x004f, 0x004f },
    { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 }, { 0x0053, 0x0053 },
    { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 }, { 0x0057, 0x0057 },
    { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a }, { 0x005b, 0x005b },
    { 0x005c, 0x005c }, { 0x005d, 0x005d }, { 0x005e, 0x005e }, { 0x005f, 0x005f },
    { 0x0060, 0x0060 }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0x007b, 0x007b },
    { 0x007c, 0x007c }, { 0x007d, 0x007d }, { 0x007e, 0x007e }, { 0x007f, 0x007f },
    { 0x0080, 0x0080 }, { 0x0081, 0x0081 }, { 0x0082, 0x0082 }, { 0x0083, 0x0083 },
    { 0x0084, 0x0084 }, { 0x0085, 0x0085 }, { 0x0086, 0x0086 }, { 0x0087, 0x0087 },
    { 0x0088, 0x0088 }, { 0x0089, 0x0089 }, { 0x008a, 0x008a }, { 0x008b, 0x008b },
    { 0x008c, 0x008c }, { 0x008d, 0x008d }, { 0x008e, 0x008e }, { 0x008f, 0x008f },
    { 0x0090, 0x0090 }, { 0x0091, 0x0091 }, { 0x0092, 0x0092 }, { 0x0093, 0x0093 },
    { 0x0094, 0x0094 }, { 0x0095, 0x0095 }, { 0x0096, 0x0096 }, { 0x0097, 0x0097 },
    { 0x0098, 0x0098 }, { 0x0099, 0x0099 }, { 0x009a, 0x009a }, { 0x009b, 0x009b },
    { 0x009c, 0x009c }, { 0x009d, 0x009d }, { 0x009e, 0x009e }, { 0x009f, 0x009f },
    { 0x00a0, 0x00a0 }, { 0x00a3, 0x00a3 }, { 0x00a4, 0x00a4 }, { 0x00a7, 0x00a7 },
    { 0x00a8, 0x00a8 }, { 0x00ad, 0x00ad }, { 0x00b0, 0x00b0 }, { 0x00b2, 0x00b2 },
    { 0x00b3, 0x00b3 }, { 0x00b4, 0x00b4 }, { 0x00b5, 0x00b5 }, { 0x00b7, 0x00b7 },
    { 0x00b8, 0x00b8 }, { 0x00bd, 0x00bd }, { 0x00c0, 0x00c0 }, { 0x00c1, 0x00c1 },
    { 0x00c2, 0x00c2 }, { 0x00c4, 0x00c4 }, { 0x00c7, 0x00c7 }, { 0x00c8, 0x00c8 },
    { 0x00c9, 0x00c9 }, { 0x00ca, 0x00ca }, { 0x00cb, 0x00cb }, { 0x00cc, 0x00cc },
    { 0x00cd, 0x00cd }, { 0x00ce, 0x00ce }, { 0x00cf, 0x00cf }, { 0x00d1, 0x00d1 },
    { 0x00d2, 0x00d2 }, { 0x00d3, 0x00d3 }, { 0x00d4, 0x00d4 }, { 0x00d6, 0x00d6 },
    { 0x00d7, 0x00d7 }, { 0x00d9, 0x00d9 }, { 0x00da, 0x00da }, { 0x00db, 0x00db },
    { 0x00dc, 0x00dc }, { 0x00df, 0x00df }, { 0x00e0, 0x00e0 }, { 0x00e1, 0x00e1 },
    { 0x00e2, 0x00e2 }, { 0x00e4, 0x00e4 }, { 0x00e7, 0x00e7 }, { 0x00e8, 0x00e8 },
    { 0x00e9, 0x00e9 }, { 0x00ea, 0x00ea }, { 0x00eb, 0x00eb }, { 0x00ec, 0x00ec },
    { 0x00ed, 0x00ed }, { 0x00ee, 0x00ee }, { 0x00ef, 0x00ef }, { 0x00f1, 0x00f1 },
    { 0x00f2, 0x00f2 }, { 0x00f3, 0x00f3 }, { 0x00f4, 0x00f4 }, { 0x00f6, 0x00f6 },
    { 0x00f7, 0x00f7 }, { 0x00f9, 0x00f9 }, { 0x00fa, 0x00fa }, { 0x00fb, 0x00fb },
    { 0x00fc, 0x00fc }, { 0x0108, 0x00c6 }, { 0x0109, 0x00e6 }, { 0x010a, 0x00c5 },
    { 0x010b, 0x00e5 }, { 0x011c, 0x00d8 }, { 0x011d, 0x00f8 }, { 0x011e, 0x00ab },
    { 0x011f, 0x00bb }, { 0x0120, 0x00d5 }, { 0x0121, 0x00f5 }, { 0x0124, 0x00a6 },
    { 0x0125, 0x00b6 }, { 0x0126, 0x00a1 }, { 0x0127, 0x00b1 }, { 0x0130, 0x00a9 },
    { 0x0131, 0x00b9 }, { 0x0134, 0x00ac }, { 0x0135, 0x00bc }, { 0x015c, 0x00de },
    { 0x015d, 0x00fe }, { 0x015e, 0x00aa }, { 0x015f, 0x00ba }, { 0x016c, 0x00dd },
    { 0x016d, 0x00fd }, { 0x017b, 0x00af }, { 0x017c, 0x00bf }, { 0x02d8, 0x00a2 },
    { 0x02d9, 0x00ff }, { 0xffff, 0x00d0 }, { 0xffff, 0x00a5 }, { 0xffff, 0x00be },
    { 0xffff, 0x00ae }, { 0xffff, 0x00e3 }, { 0xffff, 0x00f0 }, { 0xffff, 0x00c3 }
};
#endif /* USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER */

/* ISO 8859-4:1988 character set. */

#ifdef USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER
static const uint16_t sfzcl_charset_iso_8859_4[] = {
    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
    0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7,
    0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x203e,
    0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7,
    0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,
    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,
    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,
    0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,
    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,
    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,
    0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9
};

static const SfzclCharsetMap sfzcl_charset_iso_8859_4_map[] = {
    { 0x0000, 0x0000 }, { 0x0001, 0x0001 }, { 0x0002, 0x0002 }, { 0x0003, 0x0003 },
    { 0x0004, 0x0004 }, { 0x0005, 0x0005 }, { 0x0006, 0x0006 }, { 0x0007, 0x0007 },
    { 0x0008, 0x0008 }, { 0x0009, 0x0009 }, { 0x000a, 0x000a }, { 0x000b, 0x000b },
    { 0x000c, 0x000c }, { 0x000d, 0x000d }, { 0x000e, 0x000e }, { 0x000f, 0x000f },
    { 0x0010, 0x0010 }, { 0x0011, 0x0011 }, { 0x0012, 0x0012 }, { 0x0013, 0x0013 },
    { 0x0014, 0x0014 }, { 0x0015, 0x0015 }, { 0x0016, 0x0016 }, { 0x0017, 0x0017 },
    { 0x0018, 0x0018 }, { 0x0019, 0x0019 }, { 0x001a, 0x001a }, { 0x001b, 0x001b },
    { 0x001c, 0x001c }, { 0x001d, 0x001d }, { 0x001e, 0x001e }, { 0x001f, 0x001f },
    { 0x0020, 0x0020 }, { 0x0021, 0x0021 }, { 0x0022, 0x0022 }, { 0x0023, 0x0023 },
    { 0x0024, 0x0024 }, { 0x0025, 0x0025 }, { 0x0026, 0x0026 }, { 0x0027, 0x0027 },
    { 0x0028, 0x0028 }, { 0x0029, 0x0029 }, { 0x002a, 0x002a }, { 0x002b, 0x002b },
    { 0x002c, 0x002c }, { 0x002d, 0x002d }, { 0x002e, 0x002e }, { 0x002f, 0x002f },
    { 0x0030, 0x0030 }, { 0x0031, 0x0031 }, { 0x0032, 0x0032 }, { 0x0033, 0x0033 },
    { 0x0034, 0x0034 }, { 0x0035, 0x0035 }, { 0x0036, 0x0036 }, { 0x0037, 0x0037 },
    { 0x0038, 0x0038 }, { 0x0039, 0x0039 }, { 0x003a, 0x003a }, { 0x003b, 0x003b },
    { 0x003c, 0x003c }, { 0x003d, 0x003d }, { 0x003e, 0x003e }, { 0x003f, 0x003f },
    { 0x0040, 0x0040 }, { 0x0041, 0x0041 }, { 0x0042, 0x0042 }, { 0x0043, 0x0043 },
    { 0x0044, 0x0044 }, { 0x0045, 0x0045 }, { 0x0046, 0x0046 }, { 0x0047, 0x0047 },
    { 0x0048, 0x0048 }, { 0x0049, 0x0049 }, { 0x004a, 0x004a }, { 0x004b, 0x004b },
    { 0x004c, 0x004c }, { 0x004d, 0x004d }, { 0x004e, 0x004e }, { 0x004f, 0x004f },
    { 0x0050, 0x0050 }, { 0x0051, 0x0051 }, { 0x0052, 0x0052 }, { 0x0053, 0x0053 },
    { 0x0054, 0x0054 }, { 0x0055, 0x0055 }, { 0x0056, 0x0056 }, { 0x0057, 0x0057 },
    { 0x0058, 0x0058 }, { 0x0059, 0x0059 }, { 0x005a, 0x005a }, { 0x005b, 0x005b },
    { 0x005c, 0x005c }, { 0x005d, 0x005d }, { 0x005e, 0x005e }, { 0x005f, 0x005f },
    { 0x0060, 0x0060 }, { 0x0061, 0x0061 }, { 0x0062, 0x0062 }, { 0x0063, 0x0063 },
    { 0x0064, 0x0064 }, { 0x0065, 0x0065 }, { 0x0066, 0x0066 }, { 0x0067, 0x0067 },
    { 0x0068, 0x0068 }, { 0x0069, 0x0069 }, { 0x006a, 0x006a }, { 0x006b, 0x006b },
    { 0x006c, 0x006c }, { 0x006d, 0x006d }, { 0x006e, 0x006e }, { 0x006f, 0x006f },
    { 0x0070, 0x0070 }, { 0x0071, 0x0071 }, { 0x0072, 0x0072 }, { 0x0073, 0x0073 },
    { 0x0074, 0x0074 }, { 0x0075, 0x0075 }, { 0x0076, 0x0076 }, { 0x0077, 0x0077 },
    { 0x0078, 0x0078 }, { 0x0079, 0x0079 }, { 0x007a, 0x007a }, { 0x007b, 0x007b },
    { 0x007c, 0x007c }, { 0x007d, 0x007d }, { 0x007e, 0x007e }, { 0x007f, 0x007f },
    { 0x0080, 0x0080 }, { 0x0081, 0x0081 }, { 0x0082, 0x0082 }, { 0x0083, 0x0083 },
    { 0x0084, 0x0084 }, { 0x0085, 0x0085 }, { 0x0086, 0x0086 }, { 0x0087, 0x0087 },
    { 0x0088, 0x0088 }, { 0x0089, 0x0089 }, { 0x008a, 0x008a }, { 0x008b, 0x008b },
    { 0x008c, 0x008c }, { 0x008d, 0x008d }, { 0x008e, 0x008e }, { 0x008f, 0x008f },
    { 0x0090, 0x0090 }, { 0x0091, 0x0091 }, { 0x0092, 0x0092 }, { 0x0093, 0x0093 },
    { 0x0094, 0x0094 }, { 0x0095, 0x0095 }, { 0x0096, 0x0096 }, { 0x0097, 0x0097 },
    { 0x0098, 0x0098 }, { 0x0099, 0x0099 }, { 0x009a, 0x009a }, { 0x009b, 0x009b },
    { 0x009c, 0x009c }, { 0x009d, 0x009d }, { 0x009e, 0x009e }, { 0x009f, 0x009f },
    { 0x00a0, 0x00a0 }, { 0x00a4, 0x00a4 }, { 0x00a7, 0x00a7 }, { 0x00a8, 0x00a8 },
    { 0x00ad, 0x00ad }, { 0x00b0, 0x00b0 }, { 0x00b4, 0x00b4 }, { 0x00b8, 0x00b8 },
    { 0x00c1, 0x00c1 }, { 0x00c2, 0x00c2 }, { 0x00c3, 0x00c3 }, { 0x00c4, 0x00c4 },
    { 0x00c5, 0x00c5 }, { 0x00c6, 0x00c6 }, { 0x00c9, 0x00c9 }, { 0x00cb, 0x00cb },
    { 0x00cd, 0x00cd }, { 0x00ce, 0x00ce }, { 0x00d4, 0x00d4 }, { 0x00d5, 0x00d5 },
    { 0x00d6, 0x00d6 }, { 0x00d7, 0x00d7 }, { 0x00d8, 0x00d8 }, { 0x00da, 0x00da },
    { 0x00db, 0x00db }, { 0x00dc, 0x00dc }, { 0x00df, 0x00df }, { 0x00e1, 0x00e1 },
    { 0x00e2, 0x00e2 }, { 0x00e3, 0x00e3 }, { 0x00e4, 0x00e4 }, { 0x00e5, 0x00e5 },
    { 0x00e6, 0x00e6 }, { 0x00e9, 0x00e9 }, { 0x00eb, 0x00eb }, { 0x00ed, 0x00ed },
    { 0x00ee, 0x00ee }, { 0x00f4, 0x00f4 }, { 0x00f5, 0x00f5 }, { 0x00f6, 0x00f6 },
    { 0x00f7, 0x00f7 }, { 0x00f8, 0x00f8 }, { 0x00fa, 0x00fa }, { 0x00fb, 0x00fb },
    { 0x00fc, 0x00fc }, { 0x0100, 0x00c0 }, { 0x0101, 0x00e0 }, { 0x0104, 0x00a1 },
    { 0x0105, 0x00b1 }, { 0x010c, 0x00c8 }, { 0x010d, 0x00e8 }, { 0x0110, 0x00d0 },
    { 0x0111, 0x00f0 }, { 0x0112, 0x00aa }, { 0x0113, 0x00ba }, { 0x0116, 0x00cc },
    { 0x0117, 0x00ec }, { 0x0118, 0x00ca }, { 0x0119, 0x00ea }, { 0x0122, 0x00ab },
    { 0x0123, 0x00bb }, { 0x0128, 0x00a5 }, { 0x0129, 0x00b5 }, { 0x012a, 0x00cf },
    { 0x012b, 0x00ef }, { 0x012e, 0x00c7 }, { 0x012f, 0x00e7 }, { 0x0136, 0x00d3 },
    { 0x0137, 0x00f3 }, { 0x0138, 0x00a2 }, { 0x013b, 0x00a6 }, { 0x013c, 0x00b6 },
    { 0x0145, 0x00d1 }, { 0x0146, 0x00f1 }, { 0x014a, 0x00bd }, { 0x014b, 0x00bf },
    { 0x014c, 0x00d2 }, { 0x014d, 0x00f2 }, { 0x0156, 0x00a3 }, { 0x0157, 0x00b3 },
    { 0x0160, 0x00a9 }, { 0x0161, 0x00b9 }, { 0x0166, 0x00ac }, { 0x0167, 0x00bc },
    { 0x0168, 0x00dd }, { 0x0169, 0x00fd }, { 0x016a, 0x00de }, { 0x016b, 0x00fe },
    { 0x0172, 0x00d9 }, { 0x0173, 0x00f9 }, { 0x017d, 0x00ae }, { 0x017e, 0x00be },
    { 0x02c7, 0x00b7 }, { 0x02d9, 0x00ff }, { 0x02db, 0x00b2 }, { 0x203e, 0x00af }
};
#endif /* USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER */

/* This functions performs binary search in the mapping tables of the
   character sets. The mapping tables are assumed to have size 2^n for
   some n > 2 */
static uint32_t
sfzcl_charset_convert(const SfzclCharsetMap *table, size_t size,
    uint32_t unicode)
{
    uint16_t x, y, d;
    uint32_t ret;

    ret = 0xffffffff;
    y = table[0].unicode;
    if (y == unicode)
    {
        ret = table[0].mapped & 0xffff;
    }
    else
    {
        x = size >> 1;
        d = size >> 2;
        while (d)
        {
            y = table[x].unicode;
            if (y == unicode)
            {
                break;
            }
            if (y > unicode)
            {
                x -= d;
            }
            else
            {
                x += d;
            }
            d >>= 1;
        }
        y = table[x].unicode;
        if (y == unicode)
        {
            ret = table[x].mapped & 0xffff;
        }
    }
    return ret;
}

#define DEFINE_CONVERTER(source) \
    static uint32_t sfzcl_charset_unicode_to_ ## source(uint32_t character) { \
        return sfzcl_charset_convert(sfzcl_charset_ ## source ## _map, \
            sizeof(sfzcl_charset_ ## source ## _map) /  \
            sizeof(sfzcl_charset_ ## source ## _map[0]), \
            character); \
    }

DEFINE_CONVERTER(printable_string)
DEFINE_CONVERTER(visible)
DEFINE_CONVERTER(t61)

uint32_t
sfzcl_charset_unicode_to_us_ascii(uint32_t unicode)
{
    if (unicode > 0x7f)
    {
        return 0xffffffff;
    }
    return unicode;
}

uint32_t
sfzcl_charset_unicode_to_iso_8859_1(uint32_t unicode)
{
    if (unicode > 0xff)
    {
        return 0xffffffff;
    }
    return unicode;
}

uint32_t
sfzcl_charset_unicode_to_iso_8859_15(uint32_t unicode)
{
    if (unicode < 0XA4)
    {
        return unicode;
    }

    switch (unicode)
    {
    case 0X20AC:
        return 0XA4;
    case 0X0160:
        return 0XA6;
    case 0X0161:
        return 0XA8;
    case 0X017D:
        return 0XB4;
    case 0X017E:
        return 0XB8;
    case 0X0152:
        return 0XBC;
    case 0X0153:
        return 0XBD;
    case 0X0178:
        return 0XBE;
    case 0XA4:
    case 0XA6:
    case 0XA8:
    case 0XB4:
    case 0XB8:
    case 0XBC:
    case 0XBD:
    case 0XBE:
        return 0xffffffff;
    }
    if (unicode > 0xff)
    {
        return 0xffffffff;
    }
    return unicode;
}

#ifdef USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER
DEFINE_CONVERTER(iso_8859_2)
#endif
#ifdef USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER
DEFINE_CONVERTER(iso_8859_3)
#endif
#ifdef USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER
DEFINE_CONVERTER(iso_8859_4)
#endif

uint32_t
sfzcl_charset_unicode_to_bmp(uint32_t unicode)
{
    if (unicode > 0xffff)
    {
        return 0xffffffff;
    }
    return unicode;
}

uint32_t
sfzcl_charset_unicode_to_universal(uint32_t unicode)
{
    return unicode;
}

/***** Character set routines. */
/* Table to indentify printable chars. */
static const unsigned char sfzcl_charset_printable_chars[128] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    3, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 2, 0, 0, 2, 0, 2,
    0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 0, 0, 0, 0, 0,
    0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 0, 0, 0, 0, 0
};

/* Functions to handle the printable chars table. */
bool
sfzcl_str_isprintable(unsigned int byte)
{
    if (byte > 127)
    {
        return FALSE;
    }
    if (sfzcl_charset_printable_chars[byte] & 2)
    {
        return TRUE;
    }
    return FALSE;
}

SfzclCharset
sfzcl_str_charset_get(SfzclStr str)
{
    if (str == NULL)
    {
        return SFZCL_CHARSET_ANY;
    }
    return str->charset;
}

/* Convert given string `str' into the character set `charset'. */
SfzclStr
sfzcl_str_charset_convert(SfzclStr str, SfzclCharset charset)
{
    SfzclStr new_str;

    uint32_t (*converter) (uint32_t unicode);
    uint32_t pos, value, letter;
    size_t i;

    if (str == NULL)
    {
        return NULL;
    }

    /* Set up the converter. */
    converter = NULL_FNPTR;

    switch (charset)
    {
    case SFZCL_CHARSET_PRINTABLE:
        converter = sfzcl_charset_unicode_to_printable_string;
        break;
    case SFZCL_CHARSET_VISIBLE:
        converter = sfzcl_charset_unicode_to_visible;
        break;
    case SFZCL_CHARSET_US_ASCII:
        converter = sfzcl_charset_unicode_to_us_ascii;
        break;
    case SFZCL_CHARSET_ISO_8859_1:
        converter = sfzcl_charset_unicode_to_iso_8859_1;
        break;
#ifdef USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER
    case SFZCL_CHARSET_ISO_8859_2:
        converter = sfzcl_charset_unicode_to_iso_8859_2;
        break;
#endif
#ifdef USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER
    case SFZCL_CHARSET_ISO_8859_3:
        converter = sfzcl_charset_unicode_to_iso_8859_3;
        break;
#endif
#ifdef USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER
    case SFZCL_CHARSET_ISO_8859_4:
        converter = sfzcl_charset_unicode_to_iso_8859_4;
        break;
#endif
    case SFZCL_CHARSET_ISO_8859_15:
        converter = sfzcl_charset_unicode_to_iso_8859_15;
        break;
    case SFZCL_CHARSET_T61:
        converter = sfzcl_charset_unicode_to_t61;
        break;
    case SFZCL_CHARSET_BMP:
        converter = sfzcl_charset_unicode_to_bmp;
        break;
    case SFZCL_CHARSET_UNIVERSAL:
        converter = sfzcl_charset_unicode_to_universal;
        break;
    case SFZCL_CHARSET_UTF8:
        converter = sfzcl_charset_unicode_to_universal;
        break;
    default:
        L_DEBUG(LF_TOTAL_PROGRESS,
            "sfzcl_str_charset_test: output charset unknown.");
        return NULL;

        /*sfzcl_fatal("sfzcl_str_charset_test: output charset unknown."); */
    }

    /* Allocate a new string with suitable initial length. */
    if ((new_str = sfzcl_str_allocate(charset, str->str_length)) == NULL)
    {
        return NULL;
    }

    /* Run the tests. */
    switch (str->charset)
    {
    case SFZCL_CHARSET_PRINTABLE:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];

            if (sfzcl_str_isprintable(pos) != TRUE)
            {
                goto failed;
            }

            value = sfzcl_charset_visible[pos];

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_VISIBLE:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];

            if (pos > 0x7f)
            {
                goto failed;
            }

            value = sfzcl_charset_visible[pos];
            if (value == 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_US_ASCII:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];

            if (pos > 0x7f)
            {
                goto failed;
            }

            letter = (*converter)(pos);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_ISO_8859_1:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];

            if (pos > 0xff)
            {
                goto failed;
            }

            letter = (*converter)(pos);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_ISO_8859_15:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];

            if (pos > 0xff)
            {
                goto failed;
            }

            switch (pos)
            {
            case 0XA4:
                value = 0X20AC;
                break;
            case 0XA6:
                value = 0X0160;
                break;
            case 0XA8:
                value = 0X0161;
                break;
            case 0XB4:
                value = 0X017D;
                break;
            case 0XB8:
                value = 0X017E;
                break;
            case 0XBC:
                value = 0X0152;
                break;
            case 0XBD:
                value = 0X0153;
                break;
            case 0XBE:
                value = 0X0178;
                break;
            default:
                value = pos;
            }
            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

#ifdef USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER
    case SFZCL_CHARSET_ISO_8859_2:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];
            value = sfzcl_charset_iso_8859_2[pos];
            if (value == 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;
#endif /* USE_SFZCL_CHARSET_ISO_8859_2_CONVERTER */
#ifdef USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER
    case SFZCL_CHARSET_ISO_8859_3:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];
            value = sfzcl_charset_iso_8859_3[pos];
            if (value == 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;
#endif /* USE_SFZCL_CHARSET_ISO_8859_3_CONVERTER */
#ifdef USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER
    case SFZCL_CHARSET_ISO_8859_4:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];
            value = sfzcl_charset_iso_8859_4[pos];
            if (value == 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;
#endif /* USE_SFZCL_CHARSET_ISO_8859_4_CONVERTER */

    case SFZCL_CHARSET_T61:
        for (i = 0; i < str->str_length; i++)
        {
            pos = str->ob.str_8bit[i];
            value = sfzcl_charset_convert(sfzcl_charset_t61_unicode_map,
                sizeof
                (sfzcl_charset_t61_unicode_map) /
                sizeof(sfzcl_charset_t61_unicode_map
                       [0]), pos);
            if ((value & 0xff00) == 0xe000 && (i + 1) < str->str_length)
            {
                /* extented. use two bytes as pos now. */
                pos = (pos << 8) | str->ob.str_8bit[i + 1];
                value =
                    sfzcl_charset_convert(sfzcl_charset_t61_unicode_map,
                        sizeof(sfzcl_charset_t61_unicode_map)
                        /
                        sizeof(sfzcl_charset_t61_unicode_map
                               [0]), pos);
                i++;
            }

            if (value == 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_BMP:
        for (i = 0; i < str->str_length; i++)
        {
            value = str->ob.str_16bit[i];

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    case SFZCL_CHARSET_UNIVERSAL:
    case SFZCL_CHARSET_UTF8:
        for (i = 0; i < str->str_length; i++)
        {
            value = str->ob.str_32bit[i];
            if (value > 0xffff)
            {
                goto failed;
            }

            letter = (*converter)(value);
            if (letter == 0xffffffff)
            {
                goto failed;
            }

            if (!sfzcl_str_append_letter(new_str, letter))
            {
                goto failed;
            }
        }
        break;

    default:
        L_DEBUG(LF_CERTLIB,
            "sfzcl_str_charset_test: character set %u not defined.",
            str->charset);
        goto failed;
        /* sfzcl_fatal("sfzcl_str_charset_test: character set %u not defined.",
           str->charset);
           break; */
    }

    return new_str;

failed:
    sfzcl_str_free(new_str);
    return NULL;
}

/***** Routines for encoding and decoding. */

/* Note: this idea of converting everything to some internal
   representation takes CPU and more memory. There are other ways
   which could be used such as lazily wait until the data is needed
   and convert only then.  However, I feel that at the moment this is
   easier to manage internally and thus I will get this code quicker
   ready. Later if you or I have time this can be changed.

   The UTF-8 coding has the advantage of taking less space than usual
   for universal strings, however, here as you can see I convert them
   to universal strings and thus take potentially even 4 times as much
   space. Too bad, but it's still easier... */

/* Handle the 16-bit strings. */

SfzclStr
sfzcl_str_decode_bmp(unsigned char *str, size_t str_length)
{
    SfzclStr bmp_str;
    size_t i;

    /* Check for error. */
    if (!str || str_length & 0x1 || str_length == 0)
    {
        return NULL;
    }

    /* Allocate the BMP string. */
    if ((bmp_str =
             sfzcl_str_allocate(SFZCL_CHARSET_BMP, str_length / 2)) == NULL)
    {
        return NULL;
    }

    /* Decode the byte string. Value MSB first. */
    for (i = 0; i < str_length; i += 2)
    {
        if (!sfzcl_str_append_letter(bmp_str,
                (((uint16_t) str[i]) << 8) |
                (((uint16_t) str[i + 1]))))
        {
            sfzcl_str_free(bmp_str);
            return NULL;
        }
    }
    return bmp_str;
}

unsigned char *
sfzcl_str_encode_bmp(SfzclStr bmp_str, size_t *str_length)
{
    unsigned char *str;
    uint32_t letter;
    size_t i;

    if (bmp_str == NULL || bmp_str->str_length == 0)
    {
        *str_length = 0;
        return NULL;
    }

    /* Allocate the string and convert. */
    if ((str = SPAL_Memory_Alloc(bmp_str->str_length * 2)) != NULL)
    {
        for (i = 0; sfzcl_str_get_letter(bmp_str, i, &letter); i++)
        {
            str[(i << 1) + 0] = (letter >> 8) & 0xff;
            str[(i << 1) + 1] = (letter) & 0xff;
        }
        *str_length = bmp_str->str_length * 2;
    }
    else
    {
        *str_length = 0;
    }
    return str;
}

/* Handle the 32-bit strings. */
SfzclStr
sfzcl_str_decode_universal(unsigned char *str, size_t str_length)
{
    SfzclStr universal_str;
    size_t i;

    /* Check for error. */
    if (str_length & 0x3 || str_length == 0)
    {
        return NULL;
    }

    /* Allocate the UNIVERSAL string and decode to MSB first. */
    if ((universal_str =
             sfzcl_str_allocate(SFZCL_CHARSET_UNIVERSAL, str_length / 4)) == NULL)
    {
        return NULL;
    }
    for (i = 0; i < str_length; i += 4)
    {
        if (!sfzcl_str_append_letter(universal_str,
                (((uint32_t) str[i]) << 24) |
                (((uint32_t) str[i + 1]) << 16) |
                (((uint32_t) str[i + 2]) << 8) |
                (((uint32_t) str[i + 3]))))
        {
            sfzcl_str_free(universal_str);
            return NULL;
        }
    }
    return universal_str;
}

unsigned char *
sfzcl_str_encode_universal(SfzclStr universal_str, size_t *str_length)
{
    unsigned char *str;
    uint32_t letter;
    size_t i;

    if (universal_str == NULL || universal_str->str_length == 0)
    {
        *str_length = 0;
        return NULL;
    }

    /* Allocate the string and convert. */
    if ((str = SPAL_Memory_Alloc(universal_str->str_length * 4)) != NULL)
    {
        for (i = 0; sfzcl_str_get_letter(universal_str, i, &letter); i++)
        {
            str[(i << 2) + 0] = (letter >> 24) & 0xff;
            str[(i << 2) + 1] = (letter >> 16) & 0xff;
            str[(i << 2) + 2] = (letter >> 8) & 0xff;
            str[(i << 2) + 3] = (letter) & 0xff;
        }
        *str_length = universal_str->str_length * 4;
    }
    else
    {
        *str_length = 0;
    }
    return str;
}

/* Handle the UTF-8 encoded strings. */
SfzclStr
sfzcl_str_decode_utf8(unsigned char *str, size_t str_length)
{
    SfzclStr utf8_str;
    uint32_t k, bits, byte, cur;
    size_t i, len, maxchar = 0;

    /* Compute the number of the characters in string. */
    for (i = 0, len = 0; i < str_length; i += k, len++)
    {
        byte = str[i];

        /* Compute the length of this character in bytes. */
        for (k = 0, bits = 0x80; byte &bits; bits >>= 1, k++)
        {
            ;
        }

        /* Check for length. */
        if (i + k > str_length)
        {
            return NULL;
        }

        if (k == 0)
        {
            k++;
        }

        if (k > maxchar)
        {
            maxchar = k;
        }
    }

    if (maxchar == 1)
    {
        /* UTF-8 string with single byte per charater is actually
           pure US ASCII and we can store it as such. */
        if ((utf8_str = sfzcl_str_allocate(SFZCL_CHARSET_US_ASCII, 0)) == NULL)
        {
            return NULL;
        }
        if ((utf8_str->ob.str_8bit = sfzcl_memdup(str, str_length)) == NULL)
        {
            goto failed;
        }
        utf8_str->str_length = str_length;
        utf8_str->mem_length = str_length;
        return utf8_str;
    }

    /* Initialize the UTF-8 string. */
    if ((utf8_str = sfzcl_str_allocate(SFZCL_CHARSET_UTF8, len)) == NULL)
    {
        return NULL;
    }

    for (i = 0; i < str_length; )
    {
        byte = str[i];

        /* Compute the length of this character in bytes. */
        for (k = 0, bits = 0x80; byte &bits; bits >>= 1, k++)
        {
            ;
        }

        /* Check for length. */
        if (i + k > str_length)
        {
            goto failed;
        }

        if (k == 0)
        {
            k++;
        }
        switch (k)
        {
        case 1:
            cur = ((uint32_t) str[i] & 0x7f);
            break;

        case 2:
            cur = ((uint32_t) str[i + 1] & 0x3f);
            cur |= ((uint32_t) str[i] & 0x1f) << 6;
            break;

        case 3:
            cur = ((uint32_t) str[i + 2] & 0x3f);
            cur |= ((uint32_t) str[i + 1] & 0x3f) << 6;
            cur |= ((uint32_t) str[i] & 0x0f) << 12;
            break;

        case 4:
            cur = ((uint32_t) str[i + 3] & 0x3f);
            cur |= ((uint32_t) str[i + 2] & 0x3f) << 6;
            cur |= ((uint32_t) str[i + 1] & 0x3f) << 12;
            cur |= ((uint32_t) str[i] & 0x07) << 18;
            break;

        case 5:
            cur = ((uint32_t) str[i + 4] & 0x3f);
            cur |= ((uint32_t) str[i + 3] & 0x3f) << 6;
            cur |= ((uint32_t) str[i + 2] & 0x3f) << 12;
            cur |= ((uint32_t) str[i + 1] & 0x3f) << 18;
            cur |= ((uint32_t) str[i] & 0x03) << 24;
            break;

        case 6:
            cur = ((uint32_t) str[i + 5] & 0x3f);
            cur |= ((uint32_t) str[i + 4] & 0x3f) << 6;
            cur |= ((uint32_t) str[i + 3] & 0x3f) << 12;
            cur |= ((uint32_t) str[i + 2] & 0x3f) << 18;
            cur |= ((uint32_t) str[i + 1] & 0x3f) << 24;
            cur |= ((uint32_t) str[i + 0] & 0x01) << 31;
            break;

        default:
            goto failed;
        } /* switch */

        if (!sfzcl_str_append_letter(utf8_str, cur))
        {
            goto failed;
        }
        i += k;
    }

    /* Return with the string. */
    return utf8_str;

failed:
    sfzcl_str_free(utf8_str);
    return NULL;
}

unsigned char *
sfzcl_str_encode_utf8(SfzclStr utf8_str, size_t *str_length)
{
    unsigned char *str;
    SfzclStr output_str;
    uint32_t cur;
    size_t i;

    if (utf8_str == NULL)
    {
        *str_length = 0;
        return NULL;
    }

    /* Initialize the str buffer. We use the 8-bit ISO-8859-1 to act
       as an ordinary octet string.
     */

    if ((output_str = sfzcl_str_allocate(SFZCL_CHARSET_ISO_8859_1,
             utf8_str->str_length)) == NULL)
    {
        *str_length = 0;
        return NULL;
    }

    for (i = 0; sfzcl_str_get_letter(utf8_str, i, &cur); i++)
    {
        /* First the most frequent customer. */
        if (cur < 0x80)
        {
            if (!sfzcl_str_append_letter(output_str, (cur >> 0) & 0x7f))
            {
                goto failed;
            }
            continue;
        }

        /* One could count the highest leading zeroes of the 'cur' to
           quickly jump to the following cases. However, in C we'd need
           a byte table and we have tables enough in this file.

           If speed (or lack of it) becomes an issue then that could be
           done. */

        if (cur < 0x800)
        {
            if (sfzcl_str_append_letter(output_str, ((cur >> 6) & 0x1f) | 0xc0)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 0) & 0x3f) | 0x80))
            {
                continue;
            }
            else
            {
                goto failed;
            }
        }
        if (cur < 0x10000)
        {
            if (sfzcl_str_append_letter
                    (output_str, ((cur >> 12) & 0x0f) | 0xe0)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 6) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 0) & 0x3f) | 0x80))
            {
                continue;
            }
            else
            {
                goto failed;
            }
        }
        if (cur < 0x200000)
        {
            if (sfzcl_str_append_letter
                    (output_str, ((cur >> 18) & 0x07) | 0xf0)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 12) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 6) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 0) & 0x3f) | 0x80))
            {
                continue;
            }
            else
            {
                goto failed;
            }
        }
        if (cur < 0x4000000)
        {
            if (sfzcl_str_append_letter
                    (output_str, ((cur >> 24) & 0x03) | 0xf8)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 18) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 12) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 6) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 0) & 0x3f) | 0x80))
            {
                continue;
            }
            else
            {
                goto failed;
            }
        }
        if (cur < 0x80000000)
        {
            if (sfzcl_str_append_letter
                    (output_str, ((cur >> 30) & 0x01) | 0xfc)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 24) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 18) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 12) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 6) & 0x3f) | 0x80)
                && sfzcl_str_append_letter(output_str,
                    ((cur >> 0) & 0x3f) | 0x80))
            {
                continue;
            }
            else
            {
                goto failed;
            }
        }

failed:
        sfzcl_str_free(output_str);
        *str_length = 0;
        return NULL;
    }

    /* Get the string directly. */
    str = sfzcl_str_get_data(output_str, str_length);
    if (str)
    {
        str[*str_length] = '\0';
    }
    sfzcl_str_free_wrapper(output_str);
    return str;
}

/* Main string routines. */
int
sfzcl_str_null(SfzclStr str)
{
    switch (str->bits)
    {
    case 8:
        return (str->ob.str_8bit == NULL) ? 1 : 0;
    case 16:
        return (str->ob.str_16bit == NULL) ? 1 : 0;
    case 32:
        return (str->ob.str_32bit == NULL) ? 1 : 0;
    default:
        break;
    }
    return 1;
}

/* Build a string from given data, this function doesn't make copies. */
SfzclStr
sfzcl_str_make(SfzclCharset charset, unsigned char *str, size_t str_length)
{
    SfzclStr new_str = NULL;

    if (str == NULL)
    {
        return NULL;
    }

    /* Handle the possible encoding, and convert to form which is easiest
       for us to handle. */

    switch (charset)
    {
    case SFZCL_CHARSET_PRINTABLE:
    case SFZCL_CHARSET_VISIBLE:
    case SFZCL_CHARSET_US_ASCII:
    case SFZCL_CHARSET_ISO_8859_1:
    case SFZCL_CHARSET_ISO_8859_2:
    case SFZCL_CHARSET_ISO_8859_3:
    case SFZCL_CHARSET_ISO_8859_4:
    case SFZCL_CHARSET_ISO_8859_15:
    case SFZCL_CHARSET_T61:
        /* No encoding, just a plain 8-bit string. */
        if ((new_str = sfzcl_str_allocate(charset, 0)) != NULL)
        {
            new_str->ob.str_8bit = str;
            new_str->str_length = str_length;
            new_str->mem_length = str_length;
        }
        else
        {
            SPAL_Memory_Free(str);
        }
        break;
    case SFZCL_CHARSET_BMP:
        /* This has some encoding assuming msb first order. */
        new_str = sfzcl_str_decode_bmp(str, str_length);
        SPAL_Memory_Free(str);
        break;
    case SFZCL_CHARSET_UNIVERSAL:
        /* No special encoding. */
        new_str = sfzcl_str_decode_universal(str, str_length);
        SPAL_Memory_Free(str);
        break;
    case SFZCL_CHARSET_UTF8:
        /* Encoded, remove the encoding. Currently we assume that given
           UTF-8 string it is a ok to keep it stored as 32-bit universal
           string. */
        new_str = sfzcl_str_decode_utf8(str, str_length);
        SPAL_Memory_Free(str);
        break;
    default:
        SPAL_Memory_Free(str);
        return NULL;
    }

    if (new_str == NULL)
    {
        return NULL;
    }

    /* If no string available then return no string either. */
    if (sfzcl_str_null(new_str))
    {
        sfzcl_str_free(new_str);
        return NULL;
    }

    /* Return allocated string. */
    return new_str;
}

/* Build a string from given data, this function makes copies. */
SfzclStr
sfzcl_str_new(SfzclCharset charset, const void *str, size_t str_length)
{
    SfzclStr new_str;
    unsigned char *str_clone;

    if (str == NULL)
    {
        return NULL;
    }
    
    str_clone = SPAL_Memory_Alloc(str_length);
    if (str_clone)
    {
        Memcpy(str_clone, str, str_length);
    }

    new_str = sfzcl_str_make(charset, str_clone, str_length);
    return new_str;
}

/* Copy given string. */
SfzclStr
sfzcl_str_dup(SfzclStr str)
{
    SfzclStr newp;

    if (str == NULL)
    {
        return NULL;
    }

    newp = SPAL_Memory_Alloc(sizeof(*newp));
    if (!newp)
    {
        return NULL;
    }

    newp->charset = str->charset;
    newp->bits = str->bits;
    newp->str_length = str->str_length;

    switch (str->bits)
    {
    case 8:
        if ((newp->ob.str_8bit =
                 sfzcl_memdup(str->ob.str_8bit,
                     str->str_length * sizeof(unsigned char))) == NULL)
        {
            SPAL_Memory_Free(newp);
            return NULL;
        }
        break;
    case 16:
        if ((newp->ob.str_16bit =
                 sfzcl_memdup(str->ob.str_16bit,
                     str->str_length * sizeof(uint16_t))) == NULL)
        {
            SPAL_Memory_Free(newp);
            return NULL;
        }
        break;
    case 32:
        if ((newp->ob.str_32bit =
                 sfzcl_memdup(str->ob.str_32bit,
                     str->str_length * sizeof(uint32_t))) == NULL)
        {
            SPAL_Memory_Free(newp);
            return NULL;
        }
        break;
    default:
        c_memset(&newp->ob, 0, sizeof(newp->ob));
        break;
    }

    return newp;
}

SfzclStrOrdRel
sfzcl_str_cmp_internal(SfzclStr op1, SfzclStr op2)
{
    size_t i, len;

    if (op1->charset != op2->charset)
    {
        L_DEBUG(LF_TOTAL_PROGRESS, "sfzcl_str_cmp_internal:"
            " arguments not of the same character set.");
        return SFZCL_STR_ORDREL_IC;
        /* sfzcl_fatal("sfzcl_str_cmp_internal:"
           " arguments not of the same character set."); */
    }

    /* Find the correct length. */
    len = (op1->str_length <= op2->str_length) ? op1->str_length :
          op2->str_length;

#define CMP(nbits)                                                      \
    for (i = 0; i < len; i++)                                             \
    {                                                                   \
        if (op1->ob.str_ ## nbits ## bit[i] != op2->ob.str_ ## nbits ## bit[i])    \
        {                                                               \
            if (op1->ob.str_ ## nbits ## bit[i] > op2->ob.str_ ## nbits ## bit[i]) { \
                return SFZCL_STR_ORDREL_GT; }                                   \
            return SFZCL_STR_ORDREL_LT;                                     \
        }                                                               \
    }

    switch (op1->bits)
    {
    case 8:
        CMP(8);
        break;
    case 16:
        CMP(16);
        break;
    case 32:
        CMP(32);
        break;
    }

    if (op1->str_length > len)
    {
        return SFZCL_STR_ORDREL_GT;
    }
    if (op2->str_length > len)
    {
        return SFZCL_STR_ORDREL_LT;
    }

    return SFZCL_STR_ORDREL_EQ;
}

SfzclStrOrdRel
sfzcl_str_cmp(SfzclStr op1, SfzclStr op2)
{
    SfzclStrOrdRel rv;

    /* We take the convention that NULL input is infinitesimally small. */
    if (op1 == NULL || op2 == NULL)
    {
        if (op1 != NULL)
        {
            return SFZCL_STR_ORDREL_GT;
        }
        if (op2 != NULL)
        {
            return SFZCL_STR_ORDREL_LT;
        }
        return SFZCL_STR_ORDREL_EQ;
    }

    /* First attempt to convert to common character set. */
    if (op1->charset != op2->charset)
    {
        SfzclStr newp;

        newp = sfzcl_str_charset_convert(op2, op1->charset);
        if (newp != NULL)
        {
            rv = sfzcl_str_cmp_internal(op1, newp);
            sfzcl_str_free(newp);
            goto finished;
        }
        newp = sfzcl_str_charset_convert(op1, op2->charset);
        if (newp != NULL)
        {
            rv = sfzcl_str_cmp_internal(newp, op2);
            sfzcl_str_free(newp);
            goto finished;
        }
        /* Incomparable. */
        return SFZCL_STR_ORDREL_IC;
    }

    rv = sfzcl_str_cmp_internal(op1, op2);

finished:
    return rv;
}

/* Get an unsigned char string. This routine doesn't necessarily
   return canonicalized strings, but does in fact force the output to
   be of correct byte order. */
unsigned char *
sfzcl_str_get(SfzclStr str, size_t *new_str_length)
{
    unsigned char *new_str = NULL;

    if (str == NULL)
    {
        *new_str_length = 0;
        return NULL;
    }

    switch (str->bits)
    {
    case 8:
        if ((new_str = SPAL_Memory_Alloc(str->str_length + 1)) != NULL)
        {
            c_memcpy(new_str, str->ob.str_8bit, str->str_length);
            *new_str_length = str->str_length;
            new_str[str->str_length] = '\0';
        }
        else
        {
            *new_str_length = 0;
        }
        break;

    default:
        switch (str->charset)
        {
        case SFZCL_CHARSET_BMP:
            new_str = sfzcl_str_encode_bmp(str, new_str_length);
            break;

        case SFZCL_CHARSET_UNIVERSAL:
            new_str = sfzcl_str_encode_universal(str, new_str_length);
            break;

        case SFZCL_CHARSET_UTF8:
            new_str = sfzcl_str_encode_utf8(str, new_str_length);
            break;

        default:

            L_DEBUG(LF_CERTLIB,
                "sfzcl_str_get: unknown character set %u (%u bit chars).",
                str->charset, str->bits);
            return NULL;
        }
        break;
    }
    return new_str;
}

/* Gets as canonical string out of the given string as possible. */
unsigned char *
sfzcl_str_get_canonical(SfzclStr str, size_t *str_length)
{
    SfzclStr temp;
    unsigned char *new_str;
    uint32_t cur, space, first;
    size_t i;

    if (str == NULL)
    {
        *str_length = 0;
        return NULL;
    }

    /* Allocate temporary string and initialize */
    if ((temp = sfzcl_str_allocate(str->charset, str->str_length)) == NULL)
    {
        return NULL;
    }

    first = 1;
    space = 0;

    /* Remark. This code needs to be rewritten in more modular fashion. */
    for (i = 0; i < str->str_length; i++)
    {
        if (!sfzcl_str_get_letter(str, i, &cur))
        {
            break;
        }

        switch (str->charset)
        {
        case SFZCL_CHARSET_PRINTABLE:
            cur = c_tolower(cur);
            break;
        default:
            break;
        }

        switch (cur)
        {
        case 0x20:
            space = 1;
            break;
        default:
            if (space && !first)
            {
                if (!sfzcl_str_append_letter(temp, 0x20))
                {
                    sfzcl_str_free(temp);
                    return NULL;
                }
            }
            if (!sfzcl_str_append_letter(temp, cur))
            {
                sfzcl_str_free(temp);
                return NULL;
            }
            space = 0;
            first = 0;
            break;
        }
    }

    /* Convert to suitable output. */
    new_str = sfzcl_str_get(temp, str_length);
    sfzcl_str_free(temp);

    return new_str;
}

void *sfzcl_charset_convert_generic(SfzclCharset charset_in,
                                    const void *str_in,
                                    size_t str_in_length,
                                    SfzclCharset charset_out,
                                    size_t *str_out_len)
{
    unsigned char *out = NULL;
    SfzclStr str = sfzcl_str_new(charset_in, str_in, str_in_length);
    size_t ignored_len;

    if (str_out_len == NULL)
    {
        str_out_len = &ignored_len;
    }
    
    if (str)
    {
        SfzclStr str2;

        str2 = sfzcl_str_charset_convert(str, charset_out);
        if (str2)
        {
            out = sfzcl_str_get(str2, str_out_len);
            sfzcl_str_free(str2);
        }
        sfzcl_str_free(str);
    }

    return out;
}
   
/* end of file sfzclstr.c */
